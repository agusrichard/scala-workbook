# Type and Type System

**Sources**
- https://docs.scala-lang.org/scala3/book/types-introduction.html
- https://docs.scala-lang.org/scala3/book/types-inferred.html

## Introduction
- Scala is a unique language in that it’s statically typed, but often feels flexible and dynamic. For instance, thanks to type inference you can write code like this without explicitly specifying the variable types:
  ```scala
  val a = 1
  val b = 2.0
  val c = "Hi!"
  ```
- And thanks to new features, like union types in Scala 3, you can also write code like the following that expresses very concisely which values are expected as arguments and which types are returned:
  ```scala
  def isTruthy(a: Boolean | Int | String): Boolean = ???
  def dogCatOrWhatever(): Dog | Plant | Car | Sun = ???
  ```

## Inferred Types
- As with other statically typed programming languages, in Scala you can declare a type when creating a new variable:
  ```scala
  val x: Int = 1
  val y: Double = 1
  ```
- However, in Scala you generally don’t have to declare the type when defining value binders:
  ```scala
  val a = 1
  val b = List(1, 2, 3)
  val m = Map(1 -> "one", 2 -> "two")
  ```
- When you do this, Scala infers the types.
- Indeed, most variables are defined this way, and Scala’s ability to automatically infer types is one feature that makes it feel like a dynamically typed language.

## Generics
- Generic classes (or traits) take a type as a parameter within square brackets [...]. The Scala convention is to use a single letter (like A) to name those type parameters. The type can then be used inside the class as needed for method instance parameters, or on return types:
  ```scala
  // here we declare the type parameter A
  //          v
  class Stack[A]:
    private var elements: List[A] = Nil
    //                         ^
    //  Here we refer to the type parameter
    //          v
    def push(x: A): Unit =
      elements = elements.prepended(x)
    def peek: A = elements.head
    def pop(): A =
      val currentTop = peek
      elements = elements.tail
      currentTop
  ```
- This implementation of a Stack class takes any type as a parameter. The beauty of generics is that you can now create a Stack[Int], Stack[String], and so on, allowing you to reuse your implementation of a Stack for arbitrary element types. This is how you create and use a Stack[Int]:
  ```scala
  val stack = Stack[Int]
  stack.push(1)
  stack.push(2)
  println(stack.pop())  // prints 2
  println(stack.pop())  // prints 1
  ```

## Intersection Types
- Used on types, the & operator creates a so called intersection type. The type A & B represents values that are both of the type A and of the type B at the same time. For instance, the following example uses the intersection type Resettable & Growable[String]:
  ```scala
  trait Resettable:
    def reset(): Unit

  trait Growable[A]:
    def add(a: A): Unit

  def f(x: Resettable & Growable[String]): Unit =
    x.reset()
    x.add("first")
  ```
- In the method f in this example, the parameter x is required to be both a Resettable and a Growable[String].
- The members of an intersection type A & B are all the members of A and all the members of B. Therefore, as shown, Resettable & Growable[String] has member methods reset and add.
- Intersection types can be useful to describe requirements structurally. That is, in our example f, we directly express that we are happy with any value for x as long as it’s a subtype of both Resettable and Growable. We did not have to create a nominal helper trait like the following:
  ```scala
  trait Both[A] extends Resettable, Growable[A]
  def f(x: Both[String]): Unit
  ```
- There is an important difference between the two alternatives of defining f: While both allow f to be called with instances of Both, only the former allows passing instances that are subtypes of Resettable and Growable[String], but not of Both[String].
- Note that & is commutative: A & B is the same type as B & A.


## Union Types
- Used on types, the | operator creates a so-called union type. The type A | B represents values that are either of the type A or of the type B.
- In the following example, the help method accepts a parameter named id of the union type Username | Password, that can be either a Username or a Password:
  ```scala
  case class Username(name: String)
  case class Password(hash: Hash)

  def help(id: Username | Password) =
    val user = id match
      case Username(name) => lookupName(name)
      case Password(hash) => lookupPassword(hash)
    // more code here ...
  ```
- This code is a flexible and type-safe solution. If you attempt to pass in a type other than a Username or Password, the compiler flags it as an error:
  ```
  help("hi")   // error: Found: ("hi" : String)
              //        Required: Username | Password
  ```
- As shown, union types can be used to represent alternatives of several different types, without requiring those types to be part of a custom-crafted class hierarchy, or requiring explicit wrapping.
- Without union types, it would require pre-planning of the class hierarchy, like the following example illustrates:
  ```scala
  trait UsernameOrPassword
  case class Username(name: String) extends UsernameOrPassword
  case class Password(hash: Hash) extends UsernameOrPassword
  def help(id: UsernameOrPassword) = ...
  ```
- Another alternative is to define a separate enumeration type like:
  ```scala
  enum UsernameOrPassword:
    case IsUsername(u: Username)
    case IsPassword(p: Password)
  ```
- The enumeration UsernameOrPassword represents a tagged union of Username and Password. However, this way of modeling the union requires explicit wrapping and unwrapping and, for instance, Username is not a subtype of UsernameOrPassword.
- The compiler assigns a union type to an expression only if such a type is explicitly given. For instance, given these values:
  ```scala
  val name = Username("Eve")     // name: Username = Username(Eve)
  val password = Password(123)   // password: Password = Password(123)
  ```
- This REPL example shows how a union type can be used when binding a variable to the result of an if/else expression:
  ```scala
  scala> val a = if true then name else password
  val a: Object = Username(Eve)

  scala> val b: Password | Username = if true then name else password
  val b: Password | Username = Username(Eve)
  ```
- The type of a is Object, which is a supertype of Username and Password, but not the least supertype, Password | Username. If you want the least supertype you have to give it explicitly, as is done for b.
- Union types are duals of intersection types. And like & with intersection types, | is also commutative: A | B is the same type as B | A.


## Algebraic Data Types

### Enumerations
- An enumeration is used to define a type consisting of a set of named values:
  ```scala
  enum Color:
    case Red, Green, Blue

  // The above is the shorthand of this
  enum Color:
  case Red   extends Color
  case Green extends Color
  case Blue  extends Color
  ```
- Enums can be parameterized:
  ```scala
  enum Color(val rgb: Int):
    case Red   extends Color(0xFF0000)
    case Green extends Color(0x00FF00)
    case Blue  extends Color(0x0000FF)
  ```
- Enums can also have custom definitions:
  ```scala
  enum Planet(mass: Double, radius: Double):

    private final val G = 6.67300E-11
    def surfaceGravity = G * mass / (radius * radius)
    def surfaceWeight(otherMass: Double) =  otherMass * surfaceGravity

    case Mercury extends Planet(3.303e+23, 2.4397e6)
    case Venus   extends Planet(4.869e+24, 6.0518e6)
    case Earth   extends Planet(5.976e+24, 6.37814e6)
    // 5 or 6 more planets ...
  ```
- Like classes and case classes, you can also define a companion object for an enum:
  ```scala
  object Planet:
    def main(args: Array[String]) =
      val earthWeight = args(0).toDouble
      val mass = earthWeight / Earth.surfaceGravity
      for (p <- values)
        println(s"Your weight on $p is ${p.surfaceWeight(mass)}")
  ```

### Algebraic Datatypes (ADTs)
- The enum concept is general enough to also support algebraic data types (ADTs) and their generalized version (GADTs). Here’s an example that shows how an Option type can be represented as an ADT:
  ```scala
  enum Option[+T]:
    case Some(x: T)
    case None
  ```
- This example creates an Option enum with a covariant type parameter T consisting of two cases, Some and None. Some is parameterized with a value parameter x; this is a shorthand for writing a case class that extends Option. Since None is not parameterized, it’s treated as a normal enum value.
- The extends clauses that were omitted in the previous example can also be given explicitly:
  ```scala
  enum Option[+T]:
    case Some(x: T) extends Option[T]
    case None       extends Option[Nothing]
  ```
- As with normal enum values, the cases of an enum are defined in the enums companion object, so they’re referred to as Option.Some and Option.None (unless the definitions are “pulled out” with an import):
  ```scala
  scala> Option.Some("hello")
  val res1: t2.Option[String] = Some(hello)

  scala> Option.None
  val res2: t2.Option[Nothing] = None
  ```
- As with other enumeration uses, ADTs can define additional methods. For instance, here’s Option again, with an isDefined method and an Option(...) constructor in its companion object:
  ```scala
  enum Option[+T]:
    case Some(x: T)
    case None

    def isDefined: Boolean = this match
      case None => false
      case Some(_) => true

  object Option:
    def apply[T >: Null](x: T): Option[T] =
      if (x == null) None else Some(x)
  ```
- Enumerations and ADTs share the same syntactic construct, so they can be seen simply as two ends of a spectrum, and it’s perfectly possible to construct hybrids. For instance, the code below gives an implementation of Color, either with three enum values or with a parameterized case that takes an RGB value:
  ```scala
  enum Color(val rgb: Int):
    case Red   extends Color(0xFF0000)
    case Green extends Color(0x00FF00)
    case Blue  extends Color(0x0000FF)
    case Mix(mix: Int) extends Color(mix)
  ```
- So far all the enumerations that we defined consisted of different variants of values or case classes. Enumerations can also be recursive, as illustrated in the below example of encoding natural numbers:
  ```scala
  enum Nat:
    case Zero
    case Succ(n: Nat)
  ```
- For example the value Succ(Succ(Zero)) represents the number 2 in an unary encoding. Lists can be defined in a very similar way:
  ```scala
  enum List[+A]:
    case Nil
    case Cons(head: A, tail: List[A])
  ```

### Generalized Algebraic Datatypes (GADTs)
- The above notation for enumerations is very concise and serves as the perfect starting point for modeling your data types. Since we can always be more explicit, it is also possible to express types that are much more powerful: generalized algebraic datatypes (GADTs).
- Here is an example of a GADT where the type parameter (T) specifies the contents stored in the box:
  ```scala
  enum Box[T](contents: T):
    case IntBox(n: Int) extends Box[Int](n)
    case BoolBox(b: Boolean) extends Box[Boolean](b)
  ```
- Pattern matching on the particular constructor (IntBox or BoolBox) recovers the type information:
  ```scala
  def extract[T](b: Box[T]): T = b match
    case IntBox(n)  => n + 1
    case BoolBox(b) => !b
  ```

### Desugaring Enumerations
- Conceptually, enums can be thought of as defining a sealed class together with its companion object. Let’s look at the desugaring of our Color enum above:
  ```scala
  sealed abstract class Color(val rgb: Int) extends scala.reflect.Enum
  object Color:
    case object Red extends Color(0xFF0000) { def ordinal = 0 }
    case object Green extends Color(0x00FF00) { def ordinal = 1 }
    case object Blue extends Color(0x0000FF) { def ordinal = 2 }
    case class Mix(mix: Int) extends Color(mix) { def ordinal = 3 }

    def fromOrdinal(ordinal: Int): Color = ordinal match
      case 0 => Red
      case 1 => Green
      case 2 => Blue
      case _ => throw new NoSuchElementException(ordinal.toString)
  ```
- While enums could be manually encoded using other constructs, using enumerations is more concise and also comes with a few additional utilities (such as the fromOrdinal method).